<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Ugo Spark">
  
  <title>Codecademy Learn the Command Line Notes - ugodoc</title>
  

  <link rel="shortcut icon" href="../../faviconfire.ico">
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Codecademy Learn the Command Line Notes";
    var mkdocs_page_input_path = "manuals\Codecademy Learn the Command Line Notes.md";
    var mkdocs_page_url = "/manuals/Codecademy Learn the Command Line Notes/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> ugodoc</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../collection/">Collection</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>CLI</span></li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">Codecademy Learn the Command Line Notes</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#section-1-navigation">Section 1, Navigation</a></li>
                
            
                <li class="toctree-l3"><a href="#section-2-manipulation">Section 2, Manipulation</a></li>
                
            
                <li class="toctree-l3"><a href="#section-3-redirection">Section 3, Redirection</a></li>
                
            
                <li class="toctree-l3"><a href="#section-4-environment">Section 4, Environment</a></li>
                
            
                <li class="toctree-l3"><a href="#section-5-multi-users">Section 5, Multi-Users</a></li>
                
            
            </ul>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Command%20Line%20Crash%20Course/">Command Line Crash Course</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Command%20Shell/">Command Shell</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../The%20Linux%20Command%20Line/">The Linux Command Line</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Resources for Data Science</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Digital%20Humanities/">Digital Humanities</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Learn%20Git/">Learn Git</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Resources%20for%20Data%20Science/">Resources for Data Science</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Storytelling%20with%20Data/">Storytelling with Data</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>SQL.md</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Codecademy%20Learn%20SQL/">Codecademy Learn SQL</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Codecademy%20SQL%2C%20Analyzing%20Business%20Metrics/">Codecademy SQL, Analyzing Business Metrics</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Codecademy%20SQL%2C%20Table%20Transformation/">Codecademy SQL, Table Transformation</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Introduction%20to%20SQL%20JOINs/">Introduction to SQL JOINs</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Web</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../Build%20a%20Website/">Build a Website</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../HTML%20and%20CSS/">HTML and CSS</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../tests/">Tests</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">ugodoc</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>CLI &raquo;</li>
        
      
    
    <li>Codecademy Learn the Command Line Notes</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/ugoproto/ugodoc" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h3 id="learn-the-command-line">Learn the Command Line<a class="headerlink" href="#learn-the-command-line" title="Permanent link">&para;</a></h3>
<p>Codecademy.</p>
<p><strong>Table of Content</strong></p>
<div class="toc"><span class="toctitle">Content</span><ul>
<li><a href="#learn-the-command-line">Learn the Command Line</a><ul>
<li><a href="#section-1-navigation">Section 1, Navigation</a></li>
<li><a href="#section-2-manipulation">Section 2, Manipulation</a></li>
<li><a href="#section-3-redirection">Section 3, Redirection</a></li>
<li><a href="#section-4-environment">Section 4, Environment</a></li>
<li><a href="#section-5-multi-users">Section 5, Multi-Users</a></li>
</ul>
</li>
</ul>
</div>
<ul>
<li>Bash means &lsquo;Bourne again shell&rsquo;.</li>
<li>Some literacy is needed to power the PC on a terminal.</li>
<li>A CLI has its advantages over a GUI.</li>
<li>There exists other bash programs : ksh, tcsh, zsh.</li>
<li>Common terminals: Ubuntu gnome, KDE konsole, eterm, txvt, kvt, nxterm, eterm.</li>
</ul>
<h4 id="section-1-navigation">Section 1, Navigation<a class="headerlink" href="#section-1-navigation" title="Permanent link">&para;</a></h4>
<ul>
<li><code>pwd</code>; print working directory.</li>
<li><code>dir</code>; list of directory.</li>
</ul>
<hr />
<ul>
<li><code>cd</code>/<code>dir</code>; change to directory dir.</li>
<li><code>cd ~</code>, <code>cd ~user</code>; go back home to user directory.</li>
<li><code>cd ..</code>, go up one level.</li>
<li><code>cd ../..</code>, go up two levels.</li>
<li><code>cd ../../..</code>, go up three levels.</li>
<li><code>cd temp</code>, go to directory <code>temp</code>.</li>
<li><code>cd stuff</code>, if we are in dir <code>temp</code>, switch to directory <code>stuff</code>.</li>
<li><code>cd temp/stuff</code>; switch directly to directory <code>stuff</code>.</li>
<li><code>cd 'en co re'</code>; switch to directory <code>en co re</code>.</li>
</ul>
<hr />
<ul>
<li><code>mkdir aaa</code>; make directory <code>aaa</code>.</li>
<li><code>mkdir -p aaa/bbb</code>; make directory <code>aaa</code> with sub-directory <code>bbb</code>.</li>
<li><code>mkdir 'en co re'</code>; make directory <code>en co re</code>.</li>
</ul>
<hr />
<ul>
<li><code>rmdir aaa</code>; remove directory <code>aaa</code>.</li>
<li><code>rmdir 'en co re'</code>; remove directory <code>en co re</code>.</li>
<li><code>rmdir aaa/bbb</code>; remove both directory and sub-directory (if both empty).</li>
<li><code>rmdir -p aaa/bbb</code>; remove all. <em>(you cannot remove a directory if it is non-empty (filled with sub-directories and files))</em>.</li>
</ul>
<hr />
<ul>
<li><code>pushd</code>; save current location; then, change location (another directory).</li>
<li><code>popd</code>; return to pushd. <em>(for example, you are in <code>aaa</code>, type <code>pushd</code>, go to <code>bbb</code>, type <code>pushb</code>, go to <code>ccc</code>, type <code>popd</code>, return to <code>bbb</code>, type <code>popd</code>, return to <code>aaa</code>)</em>.</li>
</ul>
<hr />
<ul>
<li><code>touch iamcoo.txt</code>; create an empty text file.</li>
<li><code>touch temp/ismvoo.txt</code>; create an empty text file in the <code>temp</code> directory.</li>
</ul>
<hr />
<ul>
<li><code>less test.txt</code>; open the file and display its content.</li>
<li>Within <code>less</code> :<ul>
<li><code>q</code>; quit.</li>
<li>arrows, <code>pgUp</code>, <code>pgDn</code>; move.</li>
<li><code>h</code>; help.</li>
</ul>
</li>
<li>For other files extensions like <code>tar</code> and GNU archive, use <code>tvf</code>.</li>
</ul>
<hr />
<ul>
<li><code>exit</code>; shut down the terminal.</li>
</ul>
<hr />
<ul>
<li><code>up</code>/<code>down</code> arrow; resume a past command.</li>
<li><code>tab</code>; autocomplete.</li>
</ul>
<h4 id="section-2-manipulation">Section 2, Manipulation<a class="headerlink" href="#section-2-manipulation" title="Permanent link">&para;</a></h4>
<ul>
<li><code>ls</code>; list of directories and files.</li>
<li><code>ls /bin/bash</code>; list of a remote directory and files.</li>
<li><code>ls -a</code>; list all.</li>
<li><code>ls -t</code>; list in alphanumeric order, when they were last modified.</li>
<li><code>ls -l</code>; list in long format.</li>
<li><code>ls -la</code>; list all in long format.</li>
<li><code>ls -alt</code>; list all in long format and ordered.</li>
<li><code>ls /aaa /bbb</code>; list both directories.</li>
<li><code>ls -r</code>; list in reverse.</li>
<li><code>ls ../paint/</code>; list an upper directory.</li>
</ul>
<hr />
<ul>
<li><code>cp aaa.txt bbb.txt</code>; copy <code>aaa.txt</code> file, paste it or create a copy named <code>bbb.txt</code>.</li>
<li><code>cp aaa.txt dir/</code>; copy <code>aaa.txt</code> into directory <code>dir</code>.</li>
<li><code>cp aaa.txt bbb.txt dir/</code>; copy <code>aaa.txt</code> and <code>bbb.txt</code>into directory <code>dir</code>.</li>
<li><code>cp \*.txt dir/</code>; copy all <code>.txt</code> files into directory <code>dir</code>.</li>
<li><code>cp aaa.txt dir/dir2</code>; copy <code>aaa.txt</code> into sub-directory <code>dir2</code>.</li>
<li><code>cp -r aaa bbb</code>; copy <code>dir1</code>, create a copy names <code>dir2</code> with the exact same content.</li>
<li><code>cp -i</code>; interactive, to prompt the user.</li>
<li><code>cp f\* ../paint/</code>; copy all files beginning with <code>f</code> to an upper directory.</li>
</ul>
<hr />
<ul>
<li><code>command cp</code>; get info on command <code>cp</code> (or any other command).</li>
<li><code>type cp</code>; find where command <code>cp</code> is located and what kind of command (an <code>alias</code> or <code>else</code>) (or any other command).</li>
<li><code>which cp</code>; locate command <code>cp</code> (or any other command).</li>
<li><code>cp –-help</code>; command <code>cp</code> arguments (or any other command).</li>
<li><code>man cp</code>; open the manual about command <code>cp</code> (or any other command).</li>
</ul>
<hr />
<ul>
<li><code>\*</code>; wildcard for any string.</li>
<li><code>?</code>; wildcard for any character.</li>
<li><code>\*.txt</code>; all files finishing with <code>.txt</code>.</li>
<li><code>r\*</code>; all files beginning with <code>r</code>.</li>
<li><code>??a.txt</code>; all files beginning with two characters + <code>a.txt</code>.</li>
<li><code>backup[[:digit:]]</code>; all file beginning with <code>backup</code> + any digit.</li>
<li><code>[abc]\*</code>; all files beginning with either <code>a</code>, <code>b</code> or <code>c</code></li>
<li><code>[[:upper:]]\*</code>; all files beginning with an upper case.</li>
<li><code>\*[![:lower:]]</code>; all file not finishing with a lower case.</li>
</ul>
<hr />
<ul>
<li><code>mv aaa.txt bbb.txt</code>; move file or cut <code>aaa.txt</code> and paste <code>bbb.txt</code>.</li>
<li><code>mv aaa.txt dir/</code>; move file <code>aaa.txt</code> into directory <code>dir</code>.</li>
<li><code>mv aaa.txt bbb.txt dir/</code>; move files <code>aaa.txt</code> and <code>bbb.txt</code> into directory <code>dir</code>.</li>
<li><code>mv \*.txt dir/</code>; move all <code>.txt</code> files into directory <code>dir</code>.</li>
<li><code>mv aaa.txt dir/dir2</code>; move file <code>aaa.txt</code> into sub-directory <code>dir2</code>.</li>
<li><code>mv -i</code>; interactive, prompt the user.</li>
</ul>
<hr />
<ul>
<li><code>rm aaa.txt</code>; remove file <code>aaa.txt</code>.</li>
<li><code>rm test1.txt test2.txt</code>; remove both files.</li>
<li><code>rm aaa/\*</code>; remove all files in the directory <code>aaa</code>.</li>
</ul>
<hr />
<ul>
<li><code>rm -r aaa</code>; remove directory <code>aaa</code>, must be empty.</li>
<li><code>rm -rf aaa</code>; remove directory <code>aaa</code> and its files.</li>
<li><code>rm -i</code>; interactive, prompt the user.</li>
</ul>
<h4 id="section-3-redirection">Section 3, Redirection<a class="headerlink" href="#section-3-redirection" title="Permanent link">&para;</a></h4>
<ul>
<li>Let&rsquo;s begin by taking a closer look at input and output. In the terminal, after the shell prompt, type :</li>
</ul>
<pre><code class="bash">$ echo 'Hello'
</code></pre>

<ul>
<li><code>env</code> print environment variables, name = value.</li>
<li><code>echo $[var]</code> print variables. </li>
<li><code>echo $HOME</code>.</li>
<li><code>echo $PS1</code>.</li>
<li><code>PS1="value"</code> change the variable value.</li>
<li><code>echo $PATH</code>.</li>
<li><code>PATH="value"</code>.</li>
<li><code>export PATH=/home/dir/bin:$PATH</code> append the new path to the variable PATH.</li>
<li><code>echo $PATH</code></li>
<li><code>cd $HOME</code> take us to the home directory.</li>
<li>The <code>echo</code> command accepts the string &lsquo;Hello&rsquo; as standard input, and echoes the string <code>'Hello'</code> back to the terminal as standard output. </li>
<li>Let&rsquo;s learn more about standard input, standard output, and standard error: <ul>
<li>standard input, abbreviated as <code>stdin</code>, is information inputted into the terminal through the keyboard or input device.</li>
<li>standard output, abbreviated as <code>stdout</code>, is the information outputted after a process is run.</li>
<li>standard error, abbreviated as <code>stderr</code>, is an error message outputted by a failed process.</li>
</ul>
</li>
<li>Redirection (<code>&gt;</code>) reroutes standard input, standard output, and standard error to or from a different location. In the terminal, type :</li>
</ul>
<pre><code class="bash">$ echo 'Hello' &gt; hello.txt
</code></pre>

<ul>
<li>Then type :</li>
</ul>
<pre><code class="bash">$ cat hello.txt
</code></pre>

<ul>
<li>How does redirection work?</li>
</ul>
<pre><code class="bash">$ echo 'Hello' &gt; hello.txt
</code></pre>

<ul>
<li>The <code>&gt;</code> command redirects the standard output to a file. The standard output <code>'Hello'</code> is redirected by <code>&gt;</code> to the file <code>hello.txt</code>, and entered as the standard input.</li>
</ul>
<pre><code class="bash">$ cat hello.txt
</code></pre>

<ul>
<li>
<p>The cat command outputs the contents of a file to the terminal. When you type <code>cat hello.txt</code>, the contents of <code>hello.txt</code> are displayed.</p>
</li>
<li>
<p>Let&rsquo;s practice redirection some more. In the terminal, type :</p>
</li>
</ul>
<pre><code class="bash">$ ls -l
</code></pre>

<ul>
<li>This is the filesystem we&rsquo;ll work with. Then type :</li>
</ul>
<pre><code class="bash">$ touch ocean.txt
</code></pre>

<ul>
<li>Fill the file with values (ocean names). Then :</li>
</ul>
<pre><code class="bash">$ cat oceans.txt &gt; continents.txt
</code></pre>

<ul>
<li>Use <code>cat</code> to view the contents of <code>continents.txt</code>. Notice that we only see oceans as output:</li>
</ul>
<pre><code class="bash">$ cat continents.txt
</code></pre>

<ul>
<li><code>&gt;</code> takes the standard output of the command on the left, and redirects it to the file on the right. Here the standard output of cat <code>oceans.txt</code> is redirected to <code>continents.txt</code>. Note that <code>&gt;</code> OVERWRITES all original content in continents.txt. When you view the output data by typing cat on <code>continents.txt</code>, you will see only the contents of <code>oceans.txt</code>. Now, type :</li>
</ul>
<pre><code class="bash">$ cat glaciers.txt &gt;&gt; rivers.txt
</code></pre>

<ul>
<li>Use <code>cat</code> to view the contents of <code>rivers.txt</code>:</li>
</ul>
<pre><code class="bash">$ cat rivers.txt
</code></pre>

<ul>
<li>Notice that we see both rivers and glaciers as output. Type:</li>
</ul>
<pre><code class="bash">$ cat glaciers.txt &gt;&gt; rivers.txt
</code></pre>

<ul>
<li>
<p><code>&gt;&gt;</code> takes the standard output of the command on the left and APPENDS it to the file on the right. You can view the output data of the file with cat and the filename. Here, the output data of <code>rivers.txt</code> will contain the original contents of <code>rivers.txt</code> with the content of <code>glaciers.txt</code> appended to it. </p>
</li>
<li>
<p>In the terminal type :</p>
</li>
</ul>
<pre><code class="bash">$ touch lakes.txt
</code></pre>

<ul>
<li>Fill the files with values (lake names). Then :</li>
</ul>
<pre><code class="bash">$ cat &lt; lakes.txt
</code></pre>

<ul>
<li><code>&lt;</code> takes the standard input from the file on the right and inputs it into the program on the left. Here, <code>lakes.txt</code> is the standard input for the <code>cat</code> command. The standard output appears in the terminal. Let&rsquo;s try some more redirection commands. Type :</li>
</ul>
<pre><code class="bash">$ touch volcanoes.txt
</code></pre>

<ul>
<li>Fill the files with values (volcano names). Then, type :</li>
</ul>
<pre><code class="bash">$ cat volcanoes.txt | wc
</code></pre>

<ul>
<li>You get the count for: lines, words, bytes. Now, type :</li>
</ul>
<pre><code class="bash">$ cat volcanoes.txt | wc | cat &gt; islands.txt
</code></pre>

<ul>
<li>Use <code>cat</code> to output the contents in <code>islands.txt</code>. The next command should now equals <code>$ cat volcanoes.txt | wc</code>.</li>
</ul>
<pre><code class="bash">$ cat volcanoes.txt | wc
</code></pre>

<ul>
<li><code>|</code> is a &lsquo;pipe&rsquo; or &lsquo;pipeline&rsquo; The <code>|</code> takes the standard output of the command on the left, and PIPES it as standard input to the command on the right. You can think of this as &lsquo;command to command&rsquo; redirection. Here, again, the output of cat <code>volcanoes.txt</code> is the standard input of <code>wc</code>. In turn, the <code>wc</code> command outputs the number of lines, words, and characters in <code>volcanoes.txt</code>, respectively:</li>
</ul>
<pre><code class="bash">$ cat volcanoes.txt | wc | cat &gt; islands.txt
$ less islands.txt
</code></pre>

<ul>
<li>
<p>Multiple <code>|</code>s can be chained together. Here the standard output of cat <code>volcanoes.txt</code> is &lsquo;piped&rsquo; to the <code>wc</code> command. The standard output of <code>wc</code> is then &lsquo;piped&rsquo; to cat. Finally, the standard output of cat is redirected to <code>islands.txt</code>. You can view the output data of this chain by typing cat <code>islands.txt</code>. </p>
</li>
<li>
<p>A few commands are particularly powerful when combined with redirection. Let&rsquo;s try them out. First, use <code>cat</code> to output the contents of <code>lakes.txt</code>. We&rsquo;ll begin with <code>sort</code>. Type :</p>
</li>
</ul>
<pre><code class="bash">$ sort lakes.txt
</code></pre>

<ul>
<li>Then type :</li>
</ul>
<pre><code class="bash">$ cat lakes.txt | sort &gt; sorted-lakes.txt
</code></pre>

<ul>
<li>Use cat to output the contents of <code>sorted-lakes.txt</code>.</li>
</ul>
<pre><code class="bash">$ sort lakes.txt
</code></pre>

<ul>
<li><code>sort</code> takes the standard input and orders it alphabetically for the standard output. Here, the lakes in sort <code>lakes.txt</code> are listed in alphabetical order.</li>
</ul>
<pre><code class="bash">$ cat lakes.txt | sort
</code></pre>

<ul>
<li>Or:</li>
</ul>
<pre><code class="bash">$ cat lakes.txt | sort &gt; sorted-lakes.txt
</code></pre>

<ul>
<li>Here, the command takes the standard output from cat <code>lakes.txt</code> and &lsquo;pipes&rsquo; it to sort in ascending order. The standard output of <code>sort</code> is redirected to <code>sorted-lakes.txt</code>. You can view the output data by typing :</li>
</ul>
<pre><code class="bash">$ cat sorted-lakes.txt
</code></pre>

<ul>
<li>Type :</li>
</ul>
<pre><code class="bash">$ touch deserts.txt
</code></pre>

<ul>
<li>Fill the file with values. Then, type :</li>
</ul>
<pre><code class="bash">$ cat deserts.txt
$ uniq deserts.txt
</code></pre>

<ul>
<li>Type :</li>
</ul>
<pre><code class="bash">$ sort deserts.txt | uniq
</code></pre>

<ul>
<li>Then, type :</li>
</ul>
<pre><code class="bash">$ sort deserts.txt | uniq &gt; uniq-deserts.txt
</code></pre>

<ul>
<li>Use <code>cat</code> to output the contents of <code>uniq-deserts.txt</code>.</li>
</ul>
<pre><code class="bash">$ uniq deserts.txt
</code></pre>

<ul>
<li><code>uniq</code> stands for &lsquo;unique&rsquo; and filters out ADJACENT, duplicate lines in a file. Here <code>uniq deserts.txt</code> filters out duplicates of &lsquo;Sahara Desert&rsquo;, because the duplicate of &lsquo;Sahara Desert&rsquo; directly follows the previous instance. The &lsquo;Kalahari Desert&rsquo; duplicates are not adjacent, and thus remain.</li>
</ul>
<pre><code class="bash">$ sort deserts.txt | uniq
</code></pre>

<ul>
<li>A more effective way to call <code>uniq</code> is to call sort to alphabetize a file, and &lsquo;pipe&rsquo; the standard output to <code>uniq</code>. Here by piping sort <code>deserts.txt</code> to <code>uniq</code>, all duplicate lines are alphabetized (and thereby made adjacent) and filtered out.</li>
</ul>
<pre><code class="bash">$ sort deserts.txt | uniq &gt; uniq-deserts.txt
</code></pre>

<ul>
<li>Here we simply send filtered contents to <code>uniq-deserts.txt</code>, which you can view with the cat command. Use <code>cat</code> to output the contents of <code>mountains.txt</code>. Type :</li>
</ul>
<pre><code class="bash">$ grep Mount mountains.txt
</code></pre>

<ul>
<li>Then, type :</li>
</ul>
<pre><code class="bash">$ grep -i Mount mountains.txt
$ grep Mount mountains.txt
</code></pre>

<ul>
<li><code>grep</code> stands for &lsquo;global regular expression print&rsquo;. It searches files for lines that match a pattern and returns the results. It is also case sensitive. Here, <code>grep</code> searches for &lsquo;Mount&rsquo; in <code>mountains.txt</code>.</li>
</ul>
<pre><code class="bash">$ grep -i Mount mountains.txt
</code></pre>

<ul>
<li><code>grep -i</code> enables the command to be case insensitive. Here, <code>grep</code> searches for capital or lowercase strings that match &lsquo;Mount&rsquo; in <code>mountains.txt</code>. The above commands are a great way to get started with <code>grep</code>. If you are familiar with regular expressions, you can use regular expressions to search for patterns in files. <code>grep</code> can also be used to search within a directory. Type :</li>
</ul>
<pre><code class="bash">$ grep -R Arctic /home/ccuser/workspace/geography
</code></pre>

<ul>
<li>Then, type :</li>
</ul>
<pre><code class="bash">$ grep -Rl Arctic /home/ccuser/workspace/geography
$ grep -R Arctic /home/ccuser/workspace/geography
</code></pre>

<ul>
<li><code>grep -R</code> searches all files in a directory and outputs filenames and lines containing matched results. <code>-R</code> stands for &lsquo;recursive&rsquo;. Here <code>grep -R</code> searches the <code>/home/ccuser/workspace/geography</code> directory for the string &lsquo;Arctic&rsquo; and outputs filenames and lines with matched results.</li>
</ul>
<pre><code class="bash">$ grep -R Gambino .
</code></pre>

<ul>
<li><code>grep -R</code> searches all files recursively and outputs filenames and lines containing matched results.</li>
</ul>
<pre><code class="bash">$ grep -Rl Arctic /home/ccuser/workspace/geography
</code></pre>

<ul>
<li><code>grep -Rl</code> searches all files in a directory and outputs only filenames with matched results. <code>-R</code> stands for &lsquo;recursive&rsquo; and <code>l</code> stands for &lsquo;files with matches&rsquo;. Here <code>grep -Rl</code> searches the <code>/home/ccuser/workspace/geography</code> directory for the string &lsquo;Arctic&rsquo; and outputs filenames with matched results. Use <code>cat</code> to display the contents of <code>forests.txt</code>. Type :</li>
</ul>
<pre><code class="bash">$ sed 's/snow/rain/' forests.txt
</code></pre>

<ul>
<li>Now, type :</li>
</ul>
<pre><code class="bash">$ sed 's/snow/rain/g' forests.txt
$ sed 's/snow/rain/' forests.txt
</code></pre>

<ul>
<li><code>sed</code> stands for &lsquo;stream editor&rsquo;. It accepts standard input and modifies it based on an expression, before displaying it as output data. It is similar to &lsquo;find and replace&rsquo;. </li>
<li>Let&rsquo;s look at the expression <code>'s/snow/rain/'</code>:<ul>
<li><code>s</code>: stands for &lsquo;substitution&rsquo;. it is always used when using sed for substitution.</li>
<li><code>snow</code>: the search string, the text to find.</li>
<li><code>rain</code>: the replacement string, the text to add in place.</li>
</ul>
</li>
<li>In this case, <code>sed</code> searches <code>forests.txt</code> for the word <code>'snow'</code> and replaces it with <code>'rain'</code>. Importantly, the above command will only replace the first instance of <code>'snow'</code> on a line.</li>
</ul>
<pre><code class="bash">$ sed 's/snow/rain/g' forests.txt
</code></pre>

<ul>
<li>
<p>The above command uses the <code>g</code> expression, meaning &lsquo;global&rsquo;. Here <code>sed</code> searches <code>forests.txt</code> for the word <code>'snow'</code> and replaces it with <code>'rain'</code>, globally. All instances of <code>'snow'</code> on a line will be turned to <code>'rain'</code>.</p>
</li>
<li>
<p>Let&rsquo;s summarize what we&rsquo;ve done so far.</p>
</li>
<li>Redirection reroutes standard input, standard output, and standard error.</li>
<li>The common redirection commands are:<ul>
<li><code>&gt;</code>; redirects standard output of a command to a file, overwriting previous content.</li>
<li><code>&gt;&gt;</code>; redirects standard output of a command to a file, appending new content to old content.</li>
<li><code>&lt;</code>; redirects standard input to a command.</li>
<li><code>|</code>; redirects standard output of a command to another command.</li>
</ul>
</li>
<li>A number of other commands are powerful when combined with redirection commands:<ul>
<li><code>sort</code>; sorts lines of text alphabetically.</li>
<li><code>uniq</code>; filters duplicate, adjacent lines of text.</li>
<li><code>grep</code>; searches for a text pattern and outputs it.</li>
<li><code>sed</code>; searches for a text pattern, modifies it, and outputs it.</li>
<li><code>head</code>/<code>tail</code>; <code>ls</code>, but only the top/bottom results.</li>
</ul>
</li>
</ul>
<hr />
<p>Examples :</p>
<ul>
<li><code>echo thisthat</code>; show <code>thisthat</code>.</li>
<li><code>echo $USER</code>; user variable.</li>
<li><code>echo \*</code>, <code>d\*</code>, <code>s\*</code>, <code>[[:upper]]\*</code>, <code>/usr/\*/share</code>; show the content of the current directory according to the specified string (wildcards and characters).</li>
<li><code>echo ~</code>; show <code>/home/user</code>.</li>
<li><code>echo .\*</code>; show hidden files.</li>
<li><code>echo 2 + 2</code>; show 2 + 2.</li>
<li><code>echo $((2 + 2))</code>; show 4.</li>
<li><code>echo $(($((5 \*\* 2)) \* 3))</code>; show 75.</li>
<li><code>echo Front-{A,B,C}-Back</code>; show Front-A-Back Front-B-Back Front-C-Back.</li>
<li><code>echo Number-{1...5}</code>; show Number-1 Number-2 Number-3 Number-4 Number-5.</li>
<li><code>echo {Z...A}</code>; show Z Y X W…</li>
<li><code>echo a{A{1,2}, B{3,4}}b</code>; show aS1b aA2b aB3b aB4b.</li>
<li><code>mkdir {2007...2009}-0{1...9} {2007...2009}-{10...12}</code>; show 2007-01 2007-02 2007-03 2007-04 2007-05 2007-06 2007-07 2007-08 2007-09 2007-10 2007-11 2007-12 2008-01…</li>
<li><code>echo $(ls)</code>; show, not a list, but a paragraph of files and directories.</li>
<li><code>echo $USER $((2 + 2))</code>; show user 4.</li>
<li><code>echo $(cal) or echo ' $(cal) '</code>; show a calendar.</li>
<li>With <code>.</code>, special characters become ordinary characters except for <code>$</code>, <code>\</code> or <code>'</code>; and with <code>.</code>, it doesn&rsquo;t suppress commands, variables and aliases as with <code>.</code>. Try :</li>
<li><code>echo text ~/\*.txt {a,b} $(echo foo) $((2 + 2))</code> .</li>
<li><code>echo 'text ~/\*.txt {a,b} $(echo foo) $((2 + 2))'</code> .</li>
<li><code>echo 'text ~/\*.txt {a,b} $(echo foo) $((2 + 2))'</code>.</li>
<li><code>print env | less</code>; show list of available variables.</li>
<li><code>cat test.txt</code> = view the content of file <code>text.txt</code>.</li>
<li><code>ls &gt; file.txt</code>; send command and results into a file, if the file exists, it overwrite it, use <code>cat file.txt</code> to edit it.</li>
<li><code>ls &gt;&gt; file.txt</code>; send command and results into a file, if the file exists, it appends the new content to the existing one, use <code>cat file.txt</code> to edit it.</li>
<li><code>cat test.txt &gt; bbb.txt</code>; write (overwrite) the (existing) content of <code>test.txt</code> into <code>bbb.txt</code>.</li>
<li><code>cat test.txt &gt;&gt; bbb.txt</code>; write the content of <code>test.txt</code> into <code>bbb.txt</code> or append it to <code>bbb.txt</code>.</li>
<li><code>wc test.txt</code>; count lines, words and bytes of <code>test.txt</code>.</li>
<li><code>cat test.txt | wc</code>; show the wc of <code>test.txt</code>.</li>
<li><code>cat test.txt | wc &gt; bbb.txt</code>; write the <code>wc</code> of <code>test.txt</code> into <code>bbb.txt</code>.</li>
</ul>
<hr />
<p>The use of pipes :</p>
<ul>
<li><code>sort &lt; file.txt</code>; push the content into command sort.</li>
<li><code>sort file.txt</code>; sort the content.</li>
<li><code>cat &lt; aaa.txt</code>; open file <code>aaa.txt</code> to edit.</li>
<li><code>cat aaa.txt | sort &gt; sorted_aaa.txt</code>.</li>
<li><code>uniq == sort</code>; but extract unique values only.</li>
<li><code>cat aaa.txt | uniq &gt; sorted_aaa.txt</code>.</li>
<li><code>sort &lt; file.txt &gt; sorted_file.txt</code>; &hellip;and send the results into a file.</li>
<li><code>echo 'Hello' &gt; hello.txt</code>; write Hello in <code>hello.txt</code>.</li>
<li><code>ls -l | less</code>; the list goes into the reader.</li>
<li><code>ls -l | head</code>; the list shows the 10 top lines only.</li>
<li><code>ls -l | tail</code>; the list shows the 10 bottom lines only.</li>
</ul>
<h4 id="section-4-environment">Section 4, Environment<a class="headerlink" href="#section-4-environment" title="Permanent link">&para;</a></h4>
<ul>
<li>Each time we launch the terminal application, it creates a new session. The session immediately loads settings and preferences that make up the command line environment.</li>
<li>
<p>We can configure this environment to support the commands and programs, customize greetings and command aliases, and create variables to share across commands and programs.</p>
</li>
<li>
<p>A simple, command line text editor: <code>nano</code>.</p>
</li>
<li>
<p>In the terminal, type :</p>
</li>
</ul>
<pre><code class="bash">$ nano hello.txt
</code></pre>

<ul>
<li>This will open the <code>nano</code> text editor. In <code>nano</code>, at the top of the window, type :</li>
</ul>
<pre><code class="bash">$ 'Hello, I am nano.'
</code></pre>

<ul>
<li>Using the menu at the bottom of the terminal for reference, type <code>Ctrl + O</code> (the letter, not the number) to save the file. Press <code>Enter</code>, when prompted about the filename to write. Then type <code>Ctrl + X</code> to exit <code>nano</code>. Finally, type <code>clear</code> to clear the terminal window. The command prompt should now be at the top of the window. You just edited a file in the <code>nano</code> text editor.</li>
</ul>
<pre><code class="bash">$ nano hello.txt
</code></pre>

<ul>
<li><code>nano</code> is a command line text editor. It works just like a desktop text editor, like <code>TextEdit</code> or <code>Notepad</code>, except that it is accessible from the command line and only accepts keyboard input. The command <code>nano hello.txt</code> opens a new text file named <code>hello.txt</code> in the <code>nano</code> text editor. &lsquo;Hello, I am nano&rsquo; is a text string entered in <code>nano</code> through the cursor.</li>
<li>The menu of keyboard commands at the bottom of the window allow us to save changes to <code>hello.txt</code> and exit <code>nano</code>. The <code>^</code> stands for the <code>Ctrl</code> key.<br />
<code>Ctrl + O</code> saves a file. <code>O</code> stands for output.<ul>
<li><code>Ctrl + X</code> exits the <code>nano</code> program. <code>X</code> stands for exit.</li>
<li><code>Ctrl + G</code> opens a help menu.</li>
<li><code>Clear</code> clears the terminal window, moving the command prompt to the top of the screen.</li>
<li><a href="http://www.nano-editor.org/">nano editor</a></li>
</ul>
</li>
<li>Now that you are familiar with editing text in <code>nano</code>, let&rsquo;s create a file to store environment settings. Type :</li>
</ul>
<pre><code class="bash">$ nano ~/.bash_profile
</code></pre>

<ul>
<li>This opens up a new file in <code>nano</code>. In <code>~/.bash_profile</code>, at the top of the file, type :</li>
</ul>
<pre><code class="bash">$ echo 'Welcome, Jane Doe'
</code></pre>

<ul>
<li>You can use your name in place of &lsquo;Jane Doe&rsquo;. Type <code>Ctrl + O</code> to save the file. Press <code>Enter</code> to write the filename. Type <code>Ctrl + X</code> to exit. Finally, type <code>clear</code> to clear the terminal window. In the terminal, type :</li>
</ul>
<pre><code class="bash">$ source ~/.bash_profile
</code></pre>

<ul>
<li>You should see the greeting you entered. You created a file in <code>nano</code> called <code>~/.bash_profile</code> and added a greeting.</li>
</ul>
<pre><code class="bash">$ nano ~/.bash_profile
</code></pre>

<ul>
<li><code>~/.bash_profile</code> is the name of file used to store environment settings. It is commonly called the &lsquo;bash profile&rsquo;. When a session starts, it will load the contents of the bash profile before executing commands.<ul>
<li>The <code>~</code> represents the user&rsquo;s home directory.</li>
<li>The <code>.</code> indicates a hidden file.</li>
<li>The name <code>~/.bash_profile</code> is important, since this is how the command line recognizes the bash profile.</li>
</ul>
</li>
<li>The command <code>nano ~/.bash_profile</code> opens up <code>~/.bash_profile</code> in <code>nano</code>. The text echoes &lsquo;Welcome, Jane Doe&rsquo; and creates a greeting in the bash profile, which is saved. It tells the command line to echo the string &lsquo;Welcome, Jane Doe&rsquo; when a terminal session begins. The command source <code>~/.bash_profile</code> ACTIVATES the changes in <code>~/.bash_profile</code> for the current session.</li>
<li>Now that we know what bash profile is, let&rsquo;s continue configuring the environment by adding command aliases. Open <code>~/.bash_profile</code> in <code>nano</code>. In <code>~/.bash_profile</code>, beneath the greeting you created, type :</li>
</ul>
<pre><code class="bash">$ alias pd='pwd'
</code></pre>

<ul>
<li>Save the file. Press <code>Enter</code> to write the filename. Exit <code>nano</code>. Clear the terminal window.</li>
<li>In the command line, use the source command to activate the changes in the current session.</li>
</ul>
<pre><code class="bash">$ source ~/.bash_profile
</code></pre>

<ul>
<li>Let&rsquo;s try out the alias. Type :</li>
</ul>
<pre><code class="bash">$ pd
</code></pre>

<ul>
<li>You should see the same output as you would by typing the <code>pwd</code> command. What happens when you store this alias in <code>~/.bash_profile</code>?</li>
</ul>
<pre><code class="bash">$ alias pd='pwd'
</code></pre>

<ul>
<li>
<p>The alias command allows you to create keyboard shortcuts, or aliases, for commonly used commands. Here alias <code>pd='pwd'</code> creates the alias <code>pd</code> for the <code>pwd</code> command, which is then saved in the bash profile. Each time you enter <code>pd</code>, the output will be the same as the pwd command. The command source <code>~/.bash_profile</code> makes the alias <code>pd</code> available in the current session. Each time we open up the terminal, we can use the <code>pd</code> alias.</p>
</li>
<li>
<p>Let&rsquo;s practice aliases some more. Open <code>~/.bash_profile</code> in <code>nano</code>. In the bash profile, beneath the previous alias, add :</p>
</li>
</ul>
<pre><code class="bash">$ alias hy='history'
</code></pre>

<ul>
<li>Save the file. Press <code>Enter</code> to write the filename.</li>
<li>Add another alias:</li>
</ul>
<pre><code class="bash">$ alias ll='ls -la'
</code></pre>

<ul>
<li>Save the file.</li>
<li>Press <code>Enter</code> to write the filename.</li>
<li>Exit <code>nano</code>.</li>
<li>Clear the terminal window.</li>
<li>
<p>In the command line, use source to activate the changes to the bash profile for the current session.</p>
</li>
<li>
<p>Let&rsquo;s try out the aliases. In the command line, type:</p>
</li>
</ul>
<pre><code class="bash">$ hy
</code></pre>

<ul>
<li>Now type:</li>
</ul>
<pre><code class="bash">$ ll
</code></pre>

<ul>
<li>What happens when you store the following aliases in <code>~/.bash_profile</code>?</li>
</ul>
<pre><code class="bash">$ alias hy='history'
</code></pre>

<ul>
<li><code>hy</code> is set as alias for the history command in the bash profile. The alias is then made available in the current session through source. By typing <code>hy</code>, the command line outputs a history of commands that were entered in the current session.</li>
</ul>
<pre><code class="bash">$ alias ll='ls -la'
</code></pre>

<ul>
<li>
<p><code>ll</code> is set as an alias for <code>ls -la</code> and made available in the current session through source. By typing <code>ll</code>, the command line now outputs all contents and directories in long format, including all hidden files.</p>
</li>
<li>
<p>Now that you are familiar with configuring greetings and aliases, let&rsquo;s move on to setting environment variables.</p>
</li>
<li>
<p>Open <code>~/.bash_profile</code> in <code>nano</code>.</p>
</li>
<li>
<p>In the bash profile, beneath the aliases, on a new line, type:</p>
</li>
</ul>
<pre><code class="bash">$ export USER='Jane Doe'
</code></pre>

<ul>
<li>
<p>Feel free to use your own name. Save the file. Press <code>Enter</code> to write the filename. Exit <code>nano</code>. Finally, clear the terminal.</p>
</li>
<li>
<p>In the command line, use source to activate the changes in the bash profile for the current session. Type :</p>
</li>
</ul>
<pre><code class="bash">$ echo $USER
</code></pre>

<ul>
<li>This should return the value of the variable that you set. What happens when you store this in <code>~/.bash_profile</code>?</li>
</ul>
<pre><code class="bash">$ export USER='Jane Doe'
</code></pre>

<ul>
<li>
<p>Environment variables are variables that can be used across commands and programs and hold information about the environment. The line <code>USER='Jane Doe'</code> sets the environment variable <code>USER</code> to a name <code>'Jane Doe'</code>. Usually the <code>USER</code> variable is set to the name of the computer&rsquo;s owner. The line export makes the variable to be available to all child sessions initiated from the session you are in. This is a way to make the variable persist across programs. At the command line, the command echo <code>$USER</code> returns the value of the variable. Note that <code>$</code> is always used when returning a variable&rsquo;s value. Here, the command echo <code>$USER</code> returns the name set for the variable.</p>
</li>
<li>
<p>Let&rsquo;s learn a few more environment variables, starting with the variable for the command prompt. Open <code>~/.bash_profile</code> in <code>nano</code>. On a new line, beneath the last entry, type</p>
</li>
</ul>
<pre><code class="bash">$ export PS1='&gt;&gt; '
</code></pre>

<ul>
<li>Save the file. Press Enter to write the filename. Exit <code>nano</code>. Finally, clear the terminal window. In the command line, use source to activate the changes in the bash profile for the current shell session. Let&rsquo;s try out the new command prompt. In the terminal type :</li>
</ul>
<pre><code class="bash">$ echo 'hello'
</code></pre>

<ul>
<li>Now type :</li>
</ul>
<pre><code class="bash">$ ls -alt
</code></pre>

<ul>
<li>Did you notice that the prompt has changed? What happens when this is stored in <code>~/.bash_profile</code>?</li>
</ul>
<pre><code class="bash">$ export PS1='&gt;&gt; '
</code></pre>

<ul>
<li>
<p><code>PS1</code> is a variable that defines the makeup and style of the command prompt. <code>PS1='&gt;&gt; '</code> sets the command prompt variable and exports the variable. It makes the variable available in all sub programs of the current shell. Here we change the default command prompt from <code>$</code> to <code>&gt;&gt;</code>. After using the source command, the command line displays the new command prompt. Let&rsquo;s learn about two more environment variables. </p>
</li>
<li>
<p>In the command line, type :</p>
</li>
</ul>
<pre><code class="bash">$ echo $HOME
</code></pre>

<ul>
<li>This returns the value of the <code>HOME</code> variable. What happens when you type this command?</li>
</ul>
<pre><code class="bash">$ echo $HOME
</code></pre>

<ul>
<li>The <code>HOME</code> variable is an environment variable that displays the path of the home directory. Here by typing echo <code>$HOME</code>, the terminal displays the path <code>/home/ccuser</code> as output. You can customize the <code>HOME</code> variable if needed, but in most cases this is not necessary. In the command line, type :</li>
</ul>
<pre><code class="bash">$ echo $PATH
</code></pre>

<ul>
<li>Type :</li>
</ul>
<pre><code class="bash">/bin/pwd
</code></pre>

<ul>
<li>Type :</li>
</ul>
<pre><code class="bash">/bin/ls
</code></pre>

<ul>
<li>What happens when you type this command?</li>
</ul>
<pre><code class="bash">$ echo $PATH
/home/ccuser/.gem/ruby/2.0.0/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/sbin:/bin
</code></pre>

<ul>
<li><code>PATH</code> is an environment variable that stores a list of directories separated by a colon. Looking carefully, echo <code>$PATH</code> lists the following directories:<ul>
<li><code>/home/ccuser/.gem/ruby/2.0.0/bin</code>.</li>
<li><code>/usr/local/sbin</code>.</li>
<li><code>/usr/local/bin</code>.</li>
<li><code>/usr/bin</code>.</li>
<li><code>/usr/sbin</code>.</li>
<li><code>/sbin</code>.</li>
<li><code>/bin</code>.</li>
</ul>
</li>
<li>Each directory contains scripts for the command line to execute. The <code>PATH</code> variable simply lists which directories contain scripts. For example, many COMMANDS we&rsquo;ve learned are scripts stored in the <code>/bin</code> directory.</li>
</ul>
<pre><code class="bash">$ /bin/pwd
</code></pre>

<ul>
<li>This is the script that is executed when you type the <code>pwd</code> command.</li>
</ul>
<pre><code class="bash">$ /bin/ls
</code></pre>

<ul>
<li>This is the script that is executed when you type the ls command. In advanced cases, you can customize the <code>PATH</code> variable when adding scripts of your own. In the command line type :</li>
</ul>
<pre><code class="bash">$ env
</code></pre>

<ul>
<li>Then, type :</li>
</ul>
<pre><code class="bash">$ env | grep PATH
</code></pre>

<ul>
<li>What happens when you type this command?</li>
</ul>
<pre><code class="bash">$ env
</code></pre>

<ul>
<li>The <code>env</code> command stands for &lsquo;environment&rsquo;, and returns a list of the environment variables for the current user. Here, the <code>env</code> command returns a number of variables, including <code>PATH</code>, <code>PWD</code>, <code>PS1</code>, and <code>HOME</code>.</li>
</ul>
<pre><code class="bash">$ env | grep PATH
$ env | grep aliasname
</code></pre>

<ul>
<li><code>env | grep PATH</code> is a command that displays the value of a single environment variable. Here the standard output of env is &lsquo;piped&rsquo; to the <code>grep</code> command. <code>grep</code> searches for the value of the variable <code>PATH</code> and outputs it to the terminal. You learned to use the bash profile to configure the environment. What can we generalize so far? The environment refers to the preferences and settings of the current user.</li>
<li>The <code>nano</code> editor is a command line text editor used to configure the environment.</li>
<li><code>~/.bash_profile</code> is where environment settings are stored. You can edit this file with <code>nano</code>.</li>
<li>environment variables are variables that can be used across commands and programs and hold information about the environment.</li>
<li><code>export VARIABLE='Value'</code> sets and exports an environment variable.</li>
<li><code>USER</code> is the name of the current user.</li>
<li><code>PS1</code> is the command prompt.</li>
<li><code>HOME</code> is the home directory. It is usually not customized.</li>
<li><code>PATH</code> returns a colon separated list of file paths. It is customized in advanced cases.</li>
<li><code>env</code> returns a list of environment variables.</li>
</ul>
<h4 id="section-5-multi-users">Section 5, Multi-Users<a class="headerlink" href="#section-5-multi-users" title="Permanent link">&para;</a></h4>
<ul>
<li>Linux is multi-user : multiple users at the same time as opposed to OS X or Windows; just like the UNIX mainframe computers with terminals, users and superuser concepts. Type :</li>
</ul>
<pre><code class="bash">$ ls -l
</code></pre>

<ul>
<li>
<p>Read, from left to right :</p>
<ul>
<li>With <code>–</code> or <code>d</code> (file or dir).</li>
<li>Filename or dir name, owner access (<code>r w x…-</code>).</li>
<li>Group access (<code>r w x…-</code>).</li>
<li>All access (<code>r w x…-</code>).</li>
<li>Owner group, size, date.</li>
</ul>
</li>
<li>
<p><code>chmod</code> change access rights:</p>
<ul>
<li>u ser</li>
<li>g roup</li>
<li>o thers</li>
<li>r ead 4</li>
<li>w rite 2</li>
<li>x ecute 1</li>
</ul>
</li>
<li>o+w</li>
<li>o+x</li>
<li>o-x</li>
<li>etc.</li>
<li><code>chmod o+w file1.txt</code> for example.</li>
<li>or&hellip;</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>r w x</td>
<td>111</td>
<td>7</td>
</tr>
<tr>
<td>r w -</td>
<td>110</td>
<td>6</td>
</tr>
<tr>
<td>r - -</td>
<td>100</td>
<td>4</td>
</tr>
<tr>
<td>- - -</td>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>r - x</td>
<td>101</td>
<td>5</td>
</tr>
</tbody>
</table>
<ul>
<li><code>chmod 600 file</code>; change the file access rights to r w -, -, -.</li>
<li><code>chmod 600 dir</code>; change the dir access rights.</li>
<li>How?</li>
</ul>
<pre><code class="bash">r+w+x = 4+2+1 = 7
r     = 4     = 4
    x =     1 = 1
r+w   = 4+2   = 6
etc.

u   g   o  
--- --- ---
rwx rw- --x
7   6   1
761
</code></pre>

<ul>
<li><code>su file</code> unlock the file with pw.</li>
<li><code>sudo</code> is a privilege of superuser.</li>
<li><code>sudo command</code>; superuser do command.</li>
<li><code>su</code>; superuser login.</li>
<li>
<p>password :</p>
<ul>
<li><code>chown thou file</code> assign a new owner, <code>thou</code>.</li>
<li><code>chown thou dir</code>.</li>
<li><code>sudo chnow user file</code> change the owner.</li>
<li><code>chgrp newgr file</code> assign a new group owner, <code>newgr</code>.</li>
<li><code>chgrp newgr dir</code>.</li>
<li><code>exit</code>.</li>
</ul>
</li>
<li>
<p>Linux is multi-task; multiple </p>
</li>
<li>
<p>es at the same time like OS X or Windows or UNIX; Linux kernel runs processes; they take turns at the processor(s). All programs and processes can be launched/killed from the GUI and the CLI.</p>
</li>
<li>
<p><code>top</code> show process dashboard by PID number; <code>?</code> for help, <code>q</code> for quit.</p>
</li>
<li><code>ps</code> process list.</li>
<li><code>ps aux</code> all process.</li>
<li><code>ps aux | grep "top"</code>filter top processes.</li>
<li><code>ctrl + z</code> pause a process, put it in the backgroud.</li>
<li><code>fg</code> foreground, bring back the process.</li>
<li><code>jobs</code> list paused processes.</li>
<li><code>fg #PID</code> bring back if there is more than one process on pause.</li>
<li><code>ctrl + c</code> terminate the active process.</li>
<li><code>xload</code>; display the system load in a graph, but jam the terminal; open several terminals.</li>
<li><code>xload &amp;</code>; runs in the background</li>
<li><code>CTRL + Z</code>; suspend the process and unjam the terminal.</li>
<li><code>by</code>; resume the process.</li>
<li><code>jobs</code>; list processes.</li>
<li><code>ps</code>; list processes and their #PID.</li>
<li><code>kill #</code>; kill process #PID.<br />
kill -TERM PID   terminator<br />
kill -SIGTERM PID   terminator<br />
kill -KILL   force closing<br />
kill -9 PID   force<br />
kill -STOP PID    pause</li>
<li><code>kill</code> can send a signal from the OS to a process. For example : when you log off, you send a signal to terminate a word processing program and save the file before closing.</li>
<li><code>Ff kill #</code> doesn&rsquo;t work…</li>
<li><code>kill -9 #</code>, or&hellip;</li>
<li><code>ps x | grep bad_program</code>; find # of bad processes.</li>
<li><code>kill -SIGTERM #</code>; kill the process.</li>
<li><code>kill -SIGKILL #</code>; kill the process.</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Command%20Line%20Crash%20Course/" class="btn btn-neutral float-right" title="Command Line Crash Course">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../collection/" class="btn btn-neutral" title="Collection"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/ugoproto/ugodoc" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../../collection/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../Command%20Line%20Crash%20Course/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
